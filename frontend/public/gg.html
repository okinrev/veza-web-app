<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Talas - Application Complète</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>

    <style>
        /* Masque les éléments jusqu'à ce qu'Alpine.js soit initialisé pour éviter le "flash of unstyled content" */
        [x-cloak] { display: none !important; }
        .btn-primary { @apply bg-blue-600 hover:bg-blue-700 text-white px-5 py-2 rounded-lg font-semibold transition-all duration-300 ease-in-out shadow-md hover:shadow-lg; }
        .form-input { @apply w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition-colors duration-200 ease-in-out; }
        .message { @apply px-4 py-2 rounded-md font-medium text-sm text-center; }
        .message-success { @apply bg-green-100 text-green-700; }
        .message-error { @apply bg-red-100 text-red-700; }
        .tab-button { @apply px-4 py-2 text-sm font-medium rounded-t-lg; }
        .tab-button.active { @apply bg-blue-600 text-white shadow-md; }
        .tab-button:not(.active) { @apply text-gray-700 hover:bg-gray-100; }
        .chat-messages-container {
            height: 400px; /* Fixed height for chat scroll */
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            border: 1px solid #e2e8f0;
            border-radius: 0.375rem;
            background-color: #f9fafb;
        }
    </style>

    <script>
        document.addEventListener('alpine:init', () => {
            // Main application store for global state
            Alpine.store('app', {
                isLoggedIn: false,
                username: '',
                currentTab: 'auth', // Default tab if not logged in
                message: '', // Global message for toasts
                messageType: '', // 'success' or 'error'

                async checkAuth() {
                    const token = localStorage.getItem('access_token');
                    if (token) {
                        try {
                            const res = await fetch('/users/me', {
                                headers: { 'Authorization': `Bearer ${token}` }
                            });
                            if (res.ok) {
                                const data = await res.json();
                                this.isLoggedIn = true;
                                this.username = data.username;
                                localStorage.setItem('user_id', data.id); // Ensure user_id is stored
                                return true;
                            } else {
                                // Token invalid or expired
                                localStorage.removeItem('access_token');
                                localStorage.removeItem('refresh_token');
                                localStorage.removeItem('user_id');
                                this.isLoggedIn = false;
                                this.username = '';
                                return false;
                            }
                        } catch (e) {
                            console.error("Auth check failed:", e);
                            this.isLoggedIn = false;
                            this.username = '';
                            return false;
                        }
                    }
                    this.isLoggedIn = false;
                    this.username = '';
                    return false;
                },

                logout() {
                    localStorage.removeItem('access_token');
                    localStorage.removeItem('refresh_token');
                    localStorage.removeItem('user_id');
                    localStorage.removeItem('lastTab');
                    this.isLoggedIn = false;
                    this.username = '';
                    this.currentTab = 'auth'; // Redirect to auth on logout
                    this.showMessage('Déconnecté avec succès.', 'success');
                },

                showMessage(msg, type) {
                    this.message = msg;
                    this.messageType = type;
                    setTimeout(() => {
                        this.message = '';
                        this.messageType = '';
                    }, 5000); // Message disappears after 5 seconds
                }
            });

            // Store for Direct Messages chat functionality
            Alpine.store('dmChat', {
                socket: null,
                users: [],
                selectedUser: null,
                messages: [],
                contenu: '', // Input field for new message
                myUserId: null,
                logEl: null, // Reference to the messages log element

                init() {
                    this.myUserId = localStorage.getItem('user_id');
                    if (Alpine.store('app').isLoggedIn && this.myUserId) {
                        this.connectWebSocket();
                    } else {
                        // Delay connection or show message if not logged in
                        Alpine.store('app').showMessage("Veuillez vous connecter pour accéder aux messages.", "info");
                    }
                },

                connectWebSocket() {
                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        Alpine.store('app').showMessage("Token manquant pour la connexion DM.", 'error');
                        return;
                    }
                    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                        this.socket.close(); // Close existing connection if any
                    }
                    this.socket = new WebSocket(`ws://localhost:8000/ws/dm?token=${token}`);

                    this.socket.onopen = () => {
                        console.log("WebSocket DM connecté");
                        this.socket.send(JSON.stringify({ type: "get_users" }));
                    };

                    this.socket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        console.log("DM received:", data);

                        if (data.type === "users_list") {
                            this.users = data.users.filter(u => u.id !== this.myUserId);
                        } else if (data.type === "dm_history") {
                            this.messages = data.history.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                            this.scrollToBottom();
                        } else if (data.type === "dm") {
                            // Only add message if it's for the currently selected user or from me to the selected user
                            if ((data.fromUser === this.selectedUser?.id && data.to === this.myUserId) ||
                                (data.fromUser === this.myUserId && data.to === this.selectedUser?.id)) {
                                this.messages.push(data);
                                this.scrollToBottom();
                            }
                            // Also update users list if a new DM starts a conversation with someone not selected
                            // (optional, depends on desired notification system)
                        }
                    };

                    this.socket.onclose = () => {
                        console.log("WebSocket DM déconnecté.");
                        Alpine.store('app').showMessage("Connexion DM perdue.", 'error');
                        this.socket = null; // Clear socket to allow reconnection
                    };

                    this.socket.onerror = (error) => {
                        console.error("Erreur WebSocket DM:", error);
                        Alpine.store('app').showMessage("Erreur de connexion DM.", 'error');
                    };
                },

                selectUser(user) {
                    this.selectedUser = user;
                    this.messages = [];
                    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                        this.socket.send(JSON.stringify({
                            type: "dm_history",
                            with: user.id,
                            limit: 50
                        }));
                    } else {
                        Alpine.store('app').showMessage("WebSocket DM non connecté. Réessayez.", 'error');
                        this.connectWebSocket(); // Attempt to reconnect
                    }
                },

                envoyerMessage() {
                    const content = this.contenu.trim();
                    if (!content || !this.selectedUser || !this.socket || this.socket.readyState !== WebSocket.OPEN) {
                        Alpine.store('app').showMessage("Impossible d'envoyer le message. Vérifiez la connexion et l'utilisateur.", 'error');
                        return;
                    }

                    this.socket.send(JSON.stringify({
                        type: "dm",
                        to: this.selectedUser.id,
                        content
                    }));

                    // Manually add the sent message to the local list for immediate display
                    this.messages.push({
                        fromUser: this.myUserId,
                        to: this.selectedUser.id,
                        content,
                        timestamp: new Date().toISOString(),
                        username: "Moi" // Display "Moi" for the current user's messages
                    });

                    this.scrollToBottom();
                    this.contenu = ''; // Clear input
                },

                scrollToBottom() {
                    Alpine.nextTick(() => { // Ensure DOM is updated before scrolling
                        if (this.logEl) {
                            this.logEl.scrollTop = this.logEl.scrollHeight;
                        }
                    });
                }
            });

            // Store for Room Chat functionality
            Alpine.store('roomChat', {
                socket: null,
                rooms: [],
                roomActuelle: null,
                messages: [],
                contenu: '', // Input field for new message
                logEl: null, // Reference to the messages log element

                init() {
                    if (Alpine.store('app').isLoggedIn) {
                        this.connectWebSocket();
                    } else {
                        Alpine.store('app').showMessage("Veuillez vous connecter pour accéder aux salons.", "info");
                    }
                },

                connectWebSocket() {
                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        Alpine.store('app').showMessage("Token manquant pour la connexion aux salons.", 'error');
                        return;
                    }
                    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                        this.socket.close();
                    }
                    this.socket = new WebSocket(`ws://localhost:8000/ws/room?token=${token}`);

                    this.socket.onopen = () => {
                        console.log("WebSocket Room connecté");
                        this.socket.send(JSON.stringify({ type: "get_rooms" }));
                    };

                    this.socket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        console.log("Room message received:", data);

                        if (data.type === "rooms_list") {
                            this.rooms = data.rooms;
                        } else if (data.type === "room_history") {
                            this.messages = data.history
                                .filter(m => m.room === this.roomActuelle)
                                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                            this.scrollToBottom();
                        } else if (data.username && data.content && data.room === this.roomActuelle) {
                            this.messages.push(data);
                            this.scrollToBottom();
                        }
                    };

                    this.socket.onclose = () => {
                        console.log("WebSocket Room déconnecté.");
                        Alpine.store('app').showMessage("Connexion salon perdue.", 'error');
                        this.socket = null;
                    };

                    this.socket.onerror = (error) => {
                        console.error("Erreur WebSocket Room:", error);
                        Alpine.store('app').showMessage("Erreur de connexion salon.", 'error');
                    };
                },

                scrollToBottom() {
                    Alpine.nextTick(() => { // Ensure DOM is updated before scrolling
                        if (this.logEl) {
                            this.logEl.scrollTop = this.logEl.scrollHeight;
                        }
                    });
                },

                rejoindre(room) {
                    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
                        Alpine.store('app').showMessage("WebSocket Salon non connecté. Réessayez.", 'error');
                        this.connectWebSocket();
                        return;
                    }
                    this.roomActuelle = room;
                    this.messages = [];
                    this.socket.send(JSON.stringify({ type: "join", room }));
                    this.socket.send(JSON.stringify({ type: "room_history", room, limit: 50 }));
                },

                envoyerMessage() {
                    const content = this.contenu.trim();
                    if (!content || !this.roomActuelle || !this.socket || this.socket.readyState !== WebSocket.OPEN) {
                        Alpine.store('app').showMessage("Impossible d'envoyer le message. Vérifiez la connexion et le salon.", 'error');
                        return;
                    }

                    this.socket.send(JSON.stringify({
                        type: "message",
                        room: this.roomActuelle,
                        content
                    }));
                    this.contenu = '';
                }
            });
        });

        // This is the x-data function for the body, which can access the global store
        function mainApp() {
            return {
                init() {
                    Alpine.store('app').checkAuth().then(() => {
                        if (!Alpine.store('app').isLoggedIn) {
                            Alpine.store('app').currentTab = 'auth';
                        } else {
                            const lastTab = localStorage.getItem('lastTab');
                            Alpine.store('app').currentTab = lastTab && lastTab !== 'auth' ? lastTab : 'dashboard';

                            // Initialize DM and Room chats if logged in
                            Alpine.store('dmChat').init();
                            Alpine.store('roomChat').init();
                        }
                    });

                    // Watch for currentTab changes and persist them
                    this.$watch('$store.app.currentTab', (val) => {
                        localStorage.setItem('lastTab', val);
                    });

                    // Set x-ref for DM chat log after DOM is ready
                    Alpine.effect(() => {
                        if (this.$refs.dmLog) {
                            Alpine.store('dmChat').logEl = this.$refs.dmLog;
                        }
                    });

                    // Set x-ref for Room chat log after DOM is ready
                    Alpine.effect(() => {
                        if (this.$refs.roomLog) {
                            Alpine.store('roomChat').logEl = this.$refs.roomLog;
                        }
                    });
                },

                // Getters to access store values easily in template
                get isLoggedIn() {
                    return Alpine.store('app').isLoggedIn;
                },
                get currentTab() {
                    return Alpine.store('app').currentTab;
                },
                get username() {
                    return Alpine.store('app').username;
                },
                get globalMessage() {
                    return Alpine.store('app').message;
                },
                get globalMessageType() {
                    return Alpine.store('app').messageType;
                },
                logout() {
                    Alpine.store('app').logout();
                }
            };
        }

        // x-data function for Authentication Form
        function authForm() {
            return {
                email: '',
                password: '',
                isRegistering: false, // To toggle between login and register
                username: '', // For registration
                confirmPassword: '', // For registration confirmation

                async login() {
                    Alpine.store('app').showMessage('', ''); // Clear previous messages
                    try {
                        const res = await fetch('/login', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ email: this.email, password: this.password })
                        });

                        if (res.ok) {
                            const data = await res.json();
                            localStorage.setItem('access_token', data.access_token);
                            localStorage.setItem('refresh_token', data.refresh_token);
                            localStorage.setItem('user_id', data.user_id); // Store user_id
                            Alpine.store('app').isLoggedIn = true;
                            Alpine.store('app').username = data.username;
                            Alpine.store('app').currentTab = 'dashboard';
                            Alpine.store('app').showMessage('Connexion réussie !', 'success');
                            Alpine.store('dmChat').init(); // Initialize DM chat on login
                            Alpine.store('roomChat').init(); // Initialize Room chat on login
                        } else {
                            const errorData = await res.json();
                            Alpine.store('app').showMessage(`❌ Erreur de connexion: ${errorData.detail || 'Identifiants incorrects'}`, 'error');
                        }
                    } catch (e) {
                        Alpine.store('app').showMessage(`❌ Erreur réseau: ${e.message}`, 'error');
                    }
                },

                async register() {
                    Alpine.store('app').showMessage('', ''); // Clear previous messages
                    if (this.password !== this.confirmPassword) {
                        Alpine.store('app').showMessage('Les mots de passe ne correspondent pas.', 'error');
                        return;
                    }

                    try {
                        const res = await fetch('/signup', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ email: this.email, username: this.username, password: this.password })
                        });

                        if (res.ok) {
                            const data = await res.json();
                            localStorage.setItem('access_token', data.access_token);
                            localStorage.setItem('refresh_token', data.refresh_token);
                            localStorage.setItem('user_id', data.user_id); // Store user_id
                            Alpine.store('app').isLoggedIn = true;
                            Alpine.store('app').username = data.username;
                            Alpine.store('app').currentTab = 'dashboard';
                            Alpine.store('app').showMessage('Inscription et connexion réussies !', 'success');
                            Alpine.store('dmChat').init(); // Initialize DM chat on register
                            Alpine.store('roomChat').init(); // Initialize Room chat on register
                        } else {
                            const errorData = await res.json();
                            Alpine.store('app').showMessage(`❌ Erreur d'inscription: ${errorData.detail || 'Erreur inconnue'}`, 'error');
                        }
                    } catch (e) {
                        Alpine.store('app').showMessage(`❌ Erreur réseau: ${e.message}`, 'error');
                    }
                }
            };
        }

        // x-data function for Tracks Management
        function tracksApp() {
            return {
                tracks: [],
                isLoading: false,
                uploadForm: {
                    title: '',
                    artist: '',
                    tags: '',
                    audioFile: null
                },

                init() {
                    this.loadTracks();
                },

                async loadTracks() {
                    this.isLoading = true;
                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        Alpine.store('app').showMessage('Non connecté. Veuillez vous connecter.', 'error');
                        this.isLoading = false;
                        return;
                    }

                    try {
                        const res = await fetch('/tracks/all', {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });
                        if (!res.ok) {
                            throw new Error(`Failed to fetch tracks: ${res.status}`);
                        }
                        const data = await res.json();
                        this.tracks = data.map(track => ({ ...track, isGeneratingStream: false, streamUrl: null }));
                    } catch (error) {
                        Alpine.store('app').showMessage(`❌ Erreur: ${error.message}`, 'error');
                        console.error("Error loading tracks:", error);
                    } finally {
                        this.isLoading = false;
                    }
                },

                handleFileUpload(event) {
                    this.uploadForm.audioFile = event.target.files[0];
                },

                async uploadTrack() {
                    if (!this.uploadForm.audioFile) {
                        Alpine.store('app').showMessage('Veuillez sélectionner un fichier audio.', 'error');
                        return;
                    }

                    Alpine.store('app').showMessage('Téléchargement en cours...', 'info');
                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        Alpine.store('app').showMessage('Non connecté. Veuillez vous connecter.', 'error');
                        return;
                    }

                    const formData = new FormData();
                    formData.append('title', this.uploadForm.title);
                    formData.append('artist', this.uploadForm.artist);
                    formData.append('tags', this.uploadForm.tags);
                    formData.append('audio', this.uploadForm.audioFile);

                    try {
                        const res = await fetch('/tracks', {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${token}` },
                            body: formData
                        });

                        if (res.ok) {
                            const data = await res.json();
                            Alpine.store('app').showMessage(`✅ Piste "${data.title}" ajoutée avec succès !`, 'success');
                            this.uploadForm = { title: '', artist: '', tags: '', audioFile: null }; // Reset form
                            this.$refs.audioFileInput.value = ''; // Clear file input
                            await this.loadTracks(); // Reload tracks
                        } else {
                            const errorData = await res.json();
                            Alpine.store('app').showMessage(`❌ Erreur lors de l'upload: ${errorData.detail || res.statusText}`, 'error');
                        }
                    } catch (err) {
                        Alpine.store('app').showMessage(`❌ Erreur réseau lors de l'upload: ${err.message}`, 'error');
                        console.error("Upload error:", err);
                    }
                },

                async generateStreamUrl(trackId) {
                    const trackIndex = this.tracks.findIndex(t => t.id === trackId);
                    if (trackIndex === -1) return;

                    this.tracks[trackIndex].isGeneratingStream = true;
                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        Alpine.store('app').showMessage('Non connecté.', 'error');
                        this.tracks[trackIndex].isGeneratingStream = false;
                        return;
                    }

                    try {
                        const res = await fetch(`/tracks/${trackId}/stream`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (!res.ok) {
                            Alpine.store('app').showMessage(`❌ Erreur lors de la génération du lien signé (${res.status}).`, 'error');
                            return;
                        }
                        const data = await res.json();
                        if (!data.url) {
                            Alpine.store('app').showMessage("❌ Lien de streaming manquant dans la réponse.", 'error');
                            return;
                        }
                        this.tracks[trackIndex].streamUrl = data.url;
                        // Trigger play if an audio element is directly present and ready
                        // (Requires specific setup in the template for audio element)
                    } catch (err) {
                        Alpine.store('app').showMessage("❌ Erreur lors de la lecture audio.", 'error');
                        console.error("Erreur generateStreamUrl:", err);
                    } finally {
                        Alpine.nextTick(() => {
                            this.tracks[trackIndex].isGeneratingStream = false;
                        });
                    }
                }
            };
        }

        // x-data function for User List
        function userList() {
            return {
                users: [],
                isLoading: false,

                async init() {
                    await this.loadUsers();
                },

                async loadUsers() {
                    this.isLoading = true;
                    const token = localStorage.getItem("access_token");
                    if (!token) {
                        Alpine.store('app').showMessage("Non connecté.", 'error');
                        this.isLoading = false;
                        return;
                    }

                    try {
                        const res = await fetch("/users/except-me", {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });
                        if (!res.ok) {
                            throw new Error(`Failed to fetch users: ${res.status}`);
                        }
                        const data = await res.json();
                        this.users = data;
                    } catch (error) {
                        Alpine.store('app').showMessage(`❌ Erreur lors du chargement des utilisateurs: ${error.message}`, 'error');
                        console.error("Error loading users:", error);
                    } finally {
                        this.isLoading = false;
                    }
                }
            };
        }

        // x-data function for Shared Resources
        function sharedResourcesApp() {
            return {
                resources: [],
                isLoading: false,
                filterTitle: '',
                filterTag: '',
                filterType: '',
                filterUploader: '',
                currentPage: 1,
                itemsPerPage: 10,
                uploadForm: {
                    title: '',
                    description: '',
                    tags: '',
                    type: '',
                    resourceFile: null
                },

                async init() {
                    await this.loadResources();
                },

                async loadResources() {
                    this.isLoading = true;
                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        Alpine.store('app').showMessage('Non connecté. Veuillez vous connecter.', 'error');
                        this.isLoading = false;
                        return;
                    }

                    try {
                        const res = await fetch('/resources', {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });
                        if (!res.ok) {
                            throw new Error(`Failed to fetch resources: ${res.status}`);
                        }
                        const data = await res.json();
                        this.resources = data;
                    } catch (error) {
                        Alpine.store('app').showMessage(`❌ Erreur lors du chargement des ressources: ${error.message}`, 'error');
                        console.error("Error loading resources:", error);
                    } finally {
                        this.isLoading = false;
                    }
                },

                handleResourceUpload(event) {
                    this.uploadForm.resourceFile = event.target.files[0];
                },

                async uploadResource() {
                    if (!this.uploadForm.resourceFile) {
                        Alpine.store('app').showMessage('Veuillez sélectionner un fichier à partager.', 'error');
                        return;
                    }

                    Alpine.store('app').showMessage('Téléchargement de la ressource en cours...', 'info');
                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        Alpine.store('app').showMessage('Non connecté. Veuillez vous connecter.', 'error');
                        return;
                    }

                    const formData = new FormData();
                    formData.append('title', this.uploadForm.title);
                    formData.append('description', this.uploadForm.description);
                    formData.append('tags', this.uploadForm.tags);
                    formData.append('type', this.uploadForm.type);
                    formData.append('file', this.uploadForm.resourceFile);

                    try {
                        const res = await fetch('/resources', {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${token}` },
                            body: formData
                        });

                        if (res.ok) {
                            const data = await res.json();
                            Alpine.store('app').showMessage(`✅ Ressource "${data.title}" partagée avec succès !`, 'success');
                            this.uploadForm = { title: '', description: '', tags: '', type: '', resourceFile: null }; // Reset form
                            this.$refs.resourceFileInput.value = ''; // Clear file input
                            await this.loadResources(); // Reload resources
                        } else {
                            const errorData = await res.json();
                            Alpine.store('app').showMessage(`❌ Erreur lors du partage: ${errorData.detail || res.statusText}`, 'error');
                        }
                    } catch (err) {
                        Alpine.store('app').showMessage(`❌ Erreur réseau lors du partage: ${err.message}`, 'error');
                        console.error("Resource upload error:", err);
                    }
                },

                // Filtering logic
                get filteredResources() {
                    return this.resources.filter(resource => {
                        const matchesTitle = resource.title.toLowerCase().includes(this.filterTitle.toLowerCase());
                        const matchesTag = this.filterTag ? resource.tags.toLowerCase().includes(this.filterTag.toLowerCase()) : true;
                        const matchesType = this.filterType ? resource.type === this.filterType : true;
                        const matchesUploader = this.filterUploader ? resource.uploader_username.toLowerCase().includes(this.filterUploader.toLowerCase()) : true;
                        return matchesTitle && matchesTag && matchesType && matchesUploader;
                    });
                },

                // Pagination getters
                get paginatedResources() {
                    const start = (this.currentPage - 1) * this.itemsPerPage;
                    const end = start + this.itemsPerPage;
                    return this.filteredResources.slice(start, end);
                },

                get totalPages() {
                    return Math.ceil(this.filteredResources.length / this.itemsPerPage);
                },

                get visiblePages() {
                    const pages = [];
                    const maxVisible = 5;
                    let start = Math.max(1, this.currentPage - Math.floor(maxVisible / 2));
                    let end = Math.min(this.totalPages, start + maxVisible - 1);

                    if (end - start + 1 < maxVisible) {
                        start = Math.max(1, end - maxVisible + 1);
                    }

                    for (let i = start; i <= end; i++) {
                        pages.push(i);
                    }
                    return pages;
                },

                goToPage(page) {
                    if (page >= 1 && page <= this.totalPages) {
                        this.currentPage = page;
                    }
                },

                async downloadResource(resourceId, filename) {
                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        Alpine.store('app').showMessage('Non connecté. Veuillez vous connecter.', 'error');
                        return;
                    }

                    try {
                        const response = await fetch(`/resources/${resourceId}/download`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (!response.ok) {
                            throw new Error(`Failed to download resource: ${response.status}`);
                        }

                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename; // Use the original filename
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        window.URL.revokeObjectURL(url);
                        Alpine.store('app').showMessage('Téléchargement terminé !', 'success');
                    } catch (error) {
                        Alpine.store('app').showMessage(`❌ Erreur lors du téléchargement: ${error.message}`, 'error');
                        console.error('Download error:', error);
                    }
                }
            };
        }

        // x-data function for User Settings
        function settingsApp() {
            return {
                profileForm: {
                    email: '',
                    username: ''
                },
                passwordForm: {
                    oldPassword: '',
                    newPassword: '',
                    confirmNewPassword: ''
                },

                async init() {
                    await this.loadUserProfile();
                },

                async loadUserProfile() {
                    const token = localStorage.getItem('access_token');
                    if (!token) return;
                    try {
                        const res = await fetch('/users/me', {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });
                        if (res.ok) {
                            const data = await res.json();
                            this.profileForm.email = data.email;
                            this.profileForm.username = data.username;
                        } else {
                            Alpine.store('app').showMessage('Impossible de charger le profil.', 'error');
                        }
                    } catch (e) {
                        Alpine.store('app').showMessage(`Erreur réseau: ${e.message}`, 'error');
                        console.error('Failed to load user profile:', e);
                    }
                },

                async updateProfile() {
                    Alpine.store('app').showMessage('', ''); // Clear previous messages
                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        Alpine.store('app').showMessage('Non connecté.', 'error');
                        return;
                    }
                    try {
                        const res = await fetch('/users/me', {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({ email: this.profileForm.email, username: this.profileForm.username })
                        });
                        if (res.ok) {
                            Alpine.store('app').showMessage('Profil mis à jour avec succès !', 'success');
                            Alpine.store('app').username = this.profileForm.username; // Update global username
                        } else {
                            const errorData = await res.json();
                            Alpine.store('app').showMessage(`❌ Erreur lors de la mise à jour du profil: ${errorData.detail || 'Erreur inconnue'}`, 'error');
                        }
                    } catch (e) {
                        Alpine.store('app').showMessage(`❌ Erreur réseau: ${e.message}`, 'error');
                    }
                },

                async changePassword() {
                    Alpine.store('app').showMessage('', ''); // Clear previous messages
                    if (this.passwordForm.newPassword !== this.passwordForm.confirmNewPassword) {
                        Alpine.store('app').showMessage('Les nouveaux mots de passe ne correspondent pas.', 'error');
                        return;
                    }
                    if (this.passwordForm.newPassword.length < 8) {
                        Alpine.store('app').showMessage('Le nouveau mot de passe doit contenir au moins 8 caractères.', 'error');
                        return;
                    }

                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        Alpine.store('app').showMessage('Non connecté.', 'error');
                        return;
                    }
                    try {
                        const res = await fetch('/users/password', {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({ old_password: this.passwordForm.oldPassword, new_password: this.passwordForm.newPassword })
                        });
                        if (res.ok) {
                            Alpine.store('app').showMessage('Mot de passe mis à jour avec succès !', 'success');
                            this.passwordForm = { oldPassword: '', newPassword: '', confirmNewPassword: '' }; // Reset form
                        } else {
                            const errorData = await res.json();
                            Alpine.store('app').showMessage(`❌ Erreur lors du changement de mot de passe: ${errorData.detail || 'Erreur inconnue'}`, 'error');
                        }
                    } catch (e) {
                        Alpine.store('app').showMessage(`❌ Erreur réseau: ${e.message}`, 'error');
                    }
                }
            };
        }
    </script>
</head>
<body class="bg-gray-50 text-gray-800 font-sans" x-data="mainApp()" x-init="init()">
    <div class="max-w-7xl mx-auto p-6 space-y-8">
        <div x-cloak x-show="globalMessage"
             :class="{ 'message-success': globalMessageType === 'success', 'message-error': globalMessageType === 'error' }"
             class="message fixed top-4 right-4 z-50 p-4 rounded-md shadow-lg transition-all duration-300 ease-in-out"
             x-transition:enter="transform ease-out duration-300"
             x-transition:enter-start="translate-y-2 opacity-0 sm:translate-y-0 sm:translate-x-2"
             x-transition:enter-end="translate-y-0 opacity-100 sm:translate-x-0"
             x-transition:leave="transition ease-in duration-200"
             x-transition:leave-start="opacity-100"
             x-transition:leave-end="opacity-0">
            <p x-text="globalMessage"></p>
        </div>

        <header class="flex items-center justify-between bg-white rounded-lg shadow p-6">
            <h1 class="text-4xl font-extrabold tracking-tight bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                🎵 Talas
            </h1>
            <nav x-cloak x-show="isLoggedIn" class="flex items-center gap-4">
                <span class="text-sm text-gray-600">Bienvenue, <strong x-text="username"></strong></span>
                <button @click="logout()" class="text-sm text-red-600 hover:underline">Déconnexion</button>
            </nav>
        </header>

        <nav class="bg-white rounded-lg shadow-md p-2 flex justify-center space-x-2">
            <button @click="$store.app.currentTab = 'auth'"
                    :class="{ 'active': $store.app.currentTab === 'auth' }"
                    class="tab-button" x-cloak x-show="!isLoggedIn">
                Authentification
            </button>
            <button @click="$store.app.currentTab = 'dashboard'"
                    :class="{ 'active': $store.app.currentTab === 'dashboard' }"
                    class="tab-button" x-cloak x-show="isLoggedIn">
                Tableau de Bord
            </button>
            <button @click="$store.app.currentTab = 'tracks'"
                    :class="{ 'active': $store.app.currentTab === 'tracks' }"
                    class="tab-button" x-cloak x-show="isLoggedIn">
                Pistes
            </button>
            <button @click="$store.app.currentTab = 'dm'"
                    :class="{ 'active': $store.app.currentTab === 'dm' }"
                    class="tab-button" x-cloak x-show="isLoggedIn">
                Messages Privés
            </button>
            <button @click="$store.app.currentTab = 'room'"
                    :class="{ 'active': $store.app.currentTab === 'room' }"
                    class="tab-button" x-cloak x-show="isLoggedIn">
                Salons
            </button>
            <button @click="$store.app.currentTab = 'users'"
                    :class="{ 'active': $store.app.currentTab === 'users' }"
                    class="tab-button" x-cloak x-show="isLoggedIn">
                Utilisateurs
            </button>
            <button @click="$store.app.currentTab = 'resources'"
                    :class="{ 'active': $store.app.currentTab === 'resources' }"
                    class="tab-button" x-cloak x-show="isLoggedIn">
                Ressources
            </button>
            <button @click="$store.app.currentTab = 'settings'"
                    :class="{ 'active': $store.app.currentTab === 'settings' }"
                    class="tab-button" x-cloak x-show="isLoggedIn">
                Paramètres
            </button>
        </nav>

        <section x-cloak x-show="$store.app.currentTab === 'auth' && !$store.app.isLoggedIn"
                 class="max-w-md mx-auto bg-white shadow-xl rounded-lg p-8 mb-8" x-data="authForm()">
            <h2 class="text-2xl font-bold mb-6 text-center" x-text="isRegistering ? '📝 Inscription' : '🔑 Connexion'"></h2>

            <form @submit.prevent="isRegistering ? register() : login()" class="space-y-4">
                <input type="email" x-model="email" placeholder="Email" required class="form-input" />
                <template x-if="isRegistering">
                    <input type="text" x-model="username" placeholder="Nom d'utilisateur" required class="form-input" />
                </template>
                <input type="password" x-model="password" placeholder="Mot de passe" required class="form-input" />
                <template x-if="isRegistering">
                    <input type="password" x-model="confirmPassword" placeholder="Confirmer mot de passe" required class="form-input" />
                </template>

                <button type="submit" class="btn-primary w-full"
                        x-text="isRegistering ? 'S\'inscrire' : 'Se connecter'">
                </button>
            </form>

            <p class="text-center text-sm mt-4 text-gray-600">
                <template x-if="isRegistering">
                    Déjà un compte ? <a @click="isRegistering = false" class="text-blue-600 hover:underline cursor-pointer">Se connecter</a>
                </template>
                <template x-if="!isRegistering">
                    Pas encore de compte ? <a @click="isRegistering = true" class="text-blue-600 hover:underline cursor-pointer">S'inscrire</a>
                </template>
            </p>
        </section>

        <section x-cloak x-show="$store.app.currentTab === 'dashboard' && $store.app.isLoggedIn"
                 class="bg-white rounded-lg shadow p-6">
            <h2 class="text-2xl font-semibold mb-4">Tableau de Bord</h2>
            <p class="text-lg text-gray-700">Bienvenue sur votre tableau de bord, <span x-text="$store.app.username"></span>!</p>
            <p class="mt-2 text-gray-600">Explorez les différentes fonctionnalités via les onglets ci-dessus.</p>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-6">
                <div class="bg-blue-50 p-4 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold text-blue-800 mb-2">🎶 Pistes</h3>
                    <p class="text-blue-700">Gérez et écoutez vos pistes musicales.</p>
                    <button @click="$store.app.currentTab = 'tracks'" class="btn-primary mt-4">Voir les pistes</button>
                </div>
                <div class="bg-green-50 p-4 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold text-green-800 mb-2">💬 Messagerie</h3>
                    <p class="text-green-700">Discutez en privé ou rejoignez des salons.</p>
                    <div class="flex gap-2 mt-4">
                        <button @click="$store.app.currentTab = 'dm'" class="btn-primary">Messages Privés</button>
                        <button @click="$store.app.currentTab = 'room'" class="btn-primary">Salons</button>
                    </div>
                </div>
                <div class="bg-purple-50 p-4 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold text-purple-800 mb-2">📁 Ressources</h3>
                    <p class="text-purple-700">Partagez et explorez des ressources utiles.</p>
                    <button @click="$store.app.currentTab = 'resources'" class="btn-primary mt-4">Voir les ressources</button>
                </div>
                <div class="bg-yellow-50 p-4 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold text-yellow-800 mb-2">👥 Utilisateurs</h3>
                    <p class="text-yellow-700">Trouvez et interagissez avec d'autres utilisateurs.</p>
                    <button @click="$store.app.currentTab = 'users'" class="btn-primary mt-4">Voir les utilisateurs</button>
                </div>
                <div class="bg-red-50 p-4 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold text-red-800 mb-2">⚙️ Paramètres</h3>
                    <p class="text-red-700">Mettez à jour votre profil et votre mot de passe.</p>
                    <button @click="$store.app.currentTab = 'settings'" class="btn-primary mt-4">Accéder aux paramètres</button>
                </div>
            </div>
        </section>

        <section x-cloak x-show="$store.app.currentTab === 'tracks' && $store.app.isLoggedIn"
                 class="bg-white rounded-lg shadow p-6" x-data="tracksApp()" x-init="init()">
            <h2 class="text-2xl font-semibold mb-4">Gestion des Pistes</h2>

            <div class="mb-6 border-b pb-4">
                <h3 class="text-xl font-bold mb-3">Ajouter une nouvelle piste</h3>
                <form @submit.prevent="uploadTrack()" class="space-y-4">
                    <input type="text" x-model="uploadForm.title" placeholder="Titre de la piste" required class="form-input" />
                    <input type="text" x-model="uploadForm.artist" placeholder="Nom de l’artiste" required class="form-input" />
                    <input type="text" x-model="uploadForm.tags" placeholder="Tags séparés par des virgules (ex: hiphop, trap)" class="form-input" />
                    <input type="file" @change="handleFileUpload" x-ref="audioFileInput" accept="audio/*" required class="form-input" />

                    <button type="submit" class="btn-primary">Uploader la piste</button>
                </form>
            </div>

            <h3 class="text-xl font-bold mb-3">Vos Pistes</h3>
            <div x-show="isLoading" class="text-center text-gray-500">Chargement des pistes...</div>
            <div x-cloak x-show="!isLoading && tracks.length === 0" class="text-center text-gray-500">Aucune piste disponible.</div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4" x-cloak x-show="tracks.length > 0">
                <template x-for="track in tracks" :key="track.id">
                    <div class="bg-gray-100 p-4 rounded-lg shadow-sm flex flex-col">
                        <h4 class="text-lg font-semibold" x-text="track.title"></h4>
                        <p class="text-gray-600">Artiste: <span x-text="track.artist"></span></p>
                        <p class="text-sm text-gray-500">Tags: <span x-text="track.tags"></span></p>
                        <p class="text-xs text-gray-400 mt-1">Uploaded par: <span x-text="track.uploader_username"></span> le <span x-text="new Date(track.uploaded_at).toLocaleDateString()"></span></p>

                        <div class="mt-3 flex items-center gap-2">
                            <button @click="generateStreamUrl(track.id)" :disabled="track.isGeneratingStream" class="btn-primary text-sm flex items-center justify-center">
                                <span x-show="!track.isGeneratingStream">Écouter</span>
                                <svg x-cloak x-show="track.isGeneratingStream" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            </button>
                            <template x-if="track.streamUrl">
                                <audio controls class="w-full mt-2">
                                    <source :src="track.streamUrl" type="audio/mpeg">
                                    Votre navigateur ne supporte pas l'élément audio.
                                </audio>
                            </template>
                        </div>
                    </div>
                </template>
            </div>
        </section>

        <section x-cloak x-show="$store.app.currentTab === 'dm' && $store.app.isLoggedIn"
                 class="bg-white rounded-lg shadow p-6" x-data>
            <h2 class="text-2xl font-semibold mb-4">Messages Privés</h2>

            <div class="flex gap-4">
                <div class="w-1/4 bg-gray-50 p-4 rounded-lg shadow-sm">
                    <h3 class="text-lg font-semibold mb-2">Utilisateurs</h3>
                    <template x-if="$store.dmChat.users.length === 0">
                        <p class="text-gray-500 text-sm">Aucun autre utilisateur disponible pour discuter.</p>
                    </template>
                    <template x-for="user in $store.dmChat.users" :key="user.id">
                        <button @click="$store.dmChat.selectUser(user)"
                                :class="{ 'bg-blue-100 text-blue-800': $store.dmChat.selectedUser && $store.dmChat.selectedUser.id === user.id }"
                                class="block w-full text-left p-2 hover:bg-gray-200 rounded-md mb-1">
                            <span x-text="user.username"></span>
                            <span class="text-sm text-gray-500" x-text="user.email"></span>
                        </button>
                    </template>
                </div>

                <div class="flex-1 bg-gray-50 p-4 rounded-lg shadow-sm flex flex-col">
                    <h3 class="text-lg font-semibold mb-2" x-text="$store.dmChat.selectedUser ? `Discussion avec : ${$store.dmChat.selectedUser.username}` : 'Sélectionnez un utilisateur'"></h3>

                    <div x-ref="dmLog" class="chat-messages-container mb-4">
                        <template x-if="!$store.dmChat.selectedUser">
                            <p class="text-center text-gray-500 mt-auto mb-auto">Sélectionnez un utilisateur pour commencer à discuter.</p>
                        </template>
                        <template x-for="msg in $store.dmChat.messages" :key="msg.timestamp + msg.fromUser + msg.content.substring(0,5)">
                            <div :class="{ 'self-end bg-blue-500 text-white': msg.fromUser === $store.dmChat.myUserId, 'self-start bg-gray-200 text-gray-800': msg.fromUser !== $store.dmChat.myUserId }"
                                 class="max-w-[70%] p-2 rounded-lg break-words">
                                <strong x-text="msg.fromUser === $store.dmChat.myUserId ? 'Moi' : msg.username"></strong>:
                                <span x-text="msg.content"></span>
                                <div class="text-xs mt-1" :class="{ 'text-blue-200': msg.fromUser === $store.dmChat.myUserId, 'text-gray-600': msg.fromUser !== $store.dmChat.myUserId }" x-text="new Date(msg.timestamp).toLocaleTimeString()"></div>
                            </div>
                        </template>
                    </div>

                    <form @submit.prevent="$store.dmChat.envoyerMessage()" class="flex gap-2 mt-auto"
                          x-show="$store.dmChat.selectedUser">
                        <input type="text" x-model="$store.dmChat.contenu" placeholder="Écrire un message..." class="form-input flex-1" required />
                        <button type="submit" class="btn-primary">Envoyer</button>
                    </form>
                </div>
            </div>
        </section>

        <section x-cloak x-show="$store.app.currentTab === 'room' && $store.app.isLoggedIn"
                 class="bg-white rounded-lg shadow p-6" x-data>
            <h2 class="text-2xl font-semibold mb-4">Salons Publics</h2>

            <div class="flex gap-4">
                <div class="w-1/4 bg-gray-50 p-4 rounded-lg shadow-sm">
                    <h3 class="text-lg font-semibold mb-2">Salons</h3>
                    <template x-if="$store.roomChat.rooms.length === 0">
                        <p class="text-gray-500 text-sm">Aucun salon disponible.</p>
                    </template>
                    <template x-for="r in $store.roomChat.rooms" :key="r.id">
                        <button @click="$store.roomChat.rejoindre(r.name)"
                                :class="{ 'bg-blue-100 text-blue-800': $store.roomChat.roomActuelle === r.name }"
                                class="block w-full text-left p-2 hover:bg-gray-200 rounded-md mb-1">
                            <span x-text="r.name"></span>
                        </button>
                    </template>
                </div>

                <div class="flex-1 bg-gray-50 p-4 rounded-lg shadow-sm flex flex-col">
                    <h3 class="text-lg font-semibold mb-2" x-text="$store.roomChat.roomActuelle ? `Salon : ${$store.roomChat.roomActuelle}` : 'Sélectionnez un salon'"></h3>

                    <div x-ref="roomLog" class="chat-messages-container mb-4">
                        <template x-if="!$store.roomChat.roomActuelle">
                            <p class="text-center text-gray-500 mt-auto mb-auto">Sélectionnez un salon pour commencer à discuter.</p>
                        </template>
                        <template x-for="msg in $store.roomChat.messages" :key="msg.timestamp + msg.username + msg.content.substring(0,5)">
                            <div class="p-2 rounded-lg break-words"
                                 :class="{ 'bg-blue-500 text-white self-end': msg.username === $store.app.username, 'bg-gray-200 text-gray-800 self-start': msg.username !== $store.app.username }">
                                <strong x-text="msg.username === $store.app.username ? 'Moi' : msg.username"></strong>:
                                <span x-text="msg.content"></span>
                                <div class="text-xs mt-1" :class="{ 'text-blue-200': msg.username === $store.app.username, 'text-gray-600': msg.username !== $store.app.username }" x-text="new Date(msg.timestamp).toLocaleTimeString()"></div>
                            </div>
                        </template>
                    </div>

                    <form @submit.prevent="$store.roomChat.envoyerMessage()" class="flex gap-2 mt-auto"
                          x-show="$store.roomChat.roomActuelle">
                        <input type="text" x-model="$store.roomChat.contenu" placeholder="Écrire un message..." class="form-input flex-1" required />
                        <button type="submit" class="btn-primary">Envoyer</button>
                    </form>
                </div>
            </div>
        </section>

        <section x-cloak x-show="$store.app.currentTab === 'users' && $store.app.isLoggedIn"
                 class="bg-white rounded-lg shadow p-6" x-data="userList()" x-init="init()">
            <h2 class="text-2xl font-semibold mb-4">Liste des Utilisateurs</h2>
            <div x-show="isLoading" class="text-center text-gray-500">Chargement des utilisateurs...</div>
            <template x-if="!isLoading && users.length === 0">
                <p class="text-gray-500">Aucun autre utilisateur trouvé.</p>
            </template>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4" x-cloak x-show="users.length > 0">
                <template x-for="user in users" :key="user.id">
                    <div class="bg-gray-100 p-4 rounded-lg shadow-sm flex flex-col">
                        <h4 class="text-lg font-semibold" x-text="user.username"></h4>
                        <p class="text-gray-600">Email: <span x-text="user.email"></span></p>
                        <button @click="$store.dmChat.selectUser(user); $store.app.currentTab = 'dm';" class="btn-primary mt-2 text-sm">
                            Envoyer un message
                        </button>
                    </div>
                </template>
            </div>
        </section>

        <section x-cloak x-show="$store.app.currentTab === 'resources' && $store.app.isLoggedIn"
                 class="bg-white rounded-lg shadow p-6" x-data="sharedResourcesApp()" x-init="init()">
            <h2 class="text-2xl font-semibold mb-4">Ressources Partagées</h2>

            <div class="mb-6 border-b pb-4">
                <h3 class="text-xl font-bold mb-3">Partager une nouvelle ressource</h3>
                <form @submit.prevent="uploadResource()" class="space-y-4">
                    <input type="text" x-model="uploadForm.title" placeholder="Titre de la ressource" required class="form-input" />
                    <textarea x-model="uploadForm.description" placeholder="Description de la ressource" class="form-input"></textarea>
                    <input type="text" x-model="uploadForm.tags" placeholder="Tags (ex: sample, one-shot, fx)" class="form-input" />
                    <select x-model="uploadForm.type" required class="form-input">
                        <option value="">Sélectionner le type</option>
                        <option value="audio">Audio</option>
                        <option value="preset">Preset</option>
                        <option value="midi">MIDI</option>
                        <option value="document">Document</option>
                        <option value="image">Image</option>
                        <option value="other">Autre</option>
                    </select>
                    <input type="file" @change="handleResourceUpload" x-ref="resourceFileInput" required class="form-input" />

                    <button type="submit" class="btn-primary">Partager la ressource</button>
                </form>
            </div>

            <div class="mb-6 border-b pb-4">
                <h3 class="text-xl font-bold mb-3">Rechercher des ressources</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <input type="text" x-model="filterTitle" placeholder="Filtrer par titre..." class="form-input" />
                    <input type="text" x-model="filterTag" placeholder="Filtrer par tag..." class="form-input" />
                    <select x-model="filterType" class="form-input">
                        <option value="">Tous les types</option>
                        <option value="audio">Audio</option>
                        <option value="preset">Preset</option>
                        <option value="midi">MIDI</option>
                        <option value="document">Document</option>
                        <option value="image">Image</option>
                        <option value="other">Autre</option>
                    </select>
                    <input type="text" x-model="filterUploader" placeholder="Filtrer par uploader..." class="form-input" />
                </div>
            </div>

            <h3 class="text-xl font-bold mb-3">Ressources disponibles</h3>
            <div x-show="isLoading" class="text-center text-gray-500">Chargement des ressources...</div>
            <div x-cloak x-show="!isLoading && filteredResources.length === 0" class="text-center text-gray-500">Aucune ressource trouvée avec ces filtres.</div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4" x-cloak x-show="filteredResources.length > 0">
                <template x-for="resource in paginatedResources" :key="resource.id">
                    <div class="bg-gray-100 p-4 rounded-lg shadow-sm flex flex-col">
                        <h4 class="text-lg font-semibold" x-text="resource.title"></h4>
                        <p class="text-gray-600 text-sm" x-text="resource.description"></p>
                        <p class="text-xs text-gray-500">Tags: <span x-text="resource.tags"></span></p>
                        <p class="text-xs text-gray-500">Type: <span x-text="resource.type"></span></p>
                        <p class="text-xs text-gray-400 mt-1">Uploaded par: <span x-text="resource.uploader_username"></span> le <span x-text="new Date(resource.uploaded_at).toLocaleDateString()"></span></p>

                        <button @click="downloadResource(resource.id, resource.filename)" class="btn-primary mt-3 text-sm">Télécharger</button>
                    </div>
                </template>
            </div>

            <div x-cloak x-show="totalPages > 1" class="flex justify-center items-center space-x-2 mt-6">
                <button @click="goToPage(currentPage - 1)" :disabled="currentPage === 1" class="px-3 py-1 rounded-md bg-gray-200 hover:bg-gray-300 disabled:opacity-50">Précédent</button>
                <template x-for="page in visiblePages" :key="page">
                    <button @click="goToPage(page)" :class="{ 'bg-blue-600 text-white': currentPage === page, 'bg-gray-200 hover:bg-gray-300': currentPage !== page }" class="px-3 py-1 rounded-md">
                        <span x-text="page"></span>
                    </button>
                </template>
                <button @click="goToPage(currentPage + 1)" :disabled="currentPage === totalPages" class="px-3 py-1 rounded-md bg-gray-200 hover:bg-gray-300 disabled:opacity-50">Suivant</button>
            </div>
        </section>

        <section x-cloak x-show="$store.app.currentTab === 'settings' && $store.app.isLoggedIn"
                 class="bg-white rounded-lg shadow p-6" x-data="settingsApp()" x-init="init()">
            <h2 class="text-2xl font-semibold mb-4">Paramètres du Compte</h2>

            <div class="mb-6 border-b pb-4">
                <h3 class="text-xl font-bold mb-3">Mettre à jour le profil</h3>
                <form @submit.prevent="updateProfile()" class="space-y-4">
                    <label class="block">
                        <span class="text-gray-700">Nom d'utilisateur:</span>
                        <input type="text" x-model="profileForm.username" required class="form-input mt-1" />
                    </label>
                    <label class="block">
                        <span class="text-gray-700">Email:</span>
                        <input type="email" x-model="profileForm.email" required class="form-input mt-1" />
                    </label>
                    <button type="submit" class="btn-primary">Mettre à jour le profil</button>
                </form>
            </div>

            <div>
                <h3 class="text-xl font-bold mb-3">Changer le mot de passe</h3>
                <form @submit.prevent="changePassword()" class="space-y-4">
                    <label class="block">
                        <span class="text-gray-700">Ancien mot de passe:</span>
                        <input type="password" x-model="passwordForm.oldPassword" required class="form-input mt-1" />
                    </label>
                    <label class="block">
                        <span class="text-gray-700">Nouveau mot de passe:</span>
                        <input type="password" x-model="passwordForm.newPassword" required class="form-input mt-1" />
                    </label>
                    <label class="block">
                        <span class="text-gray-700">Confirmer le nouveau mot de passe:</span>
                        <input type="password" x-model="passwordForm.confirmNewPassword" required class="form-input mt-1" />
                    </label>
                    <button type="submit" class="btn-primary">Changer le mot de passe</button>
                </form>
            </div>
        </section>

    </div>
</body>
</html>